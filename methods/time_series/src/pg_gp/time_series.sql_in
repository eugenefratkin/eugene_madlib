/* ----------------------------------------------------------------------- *//** 
 *
 * @file time_series.sql_in
 *
 * @brief implementation of time series functions in SQL
 * @date   August 2011
 *
 *
 *//* ----------------------------------------------------------------------- */

/**
@addtogroup grp_timeseries


@about

This module provide a set of basic time series operations primarily used in financial sector. It is mainly written as a 

@input

<b>Normalization Functions</b>

These functions are meant to make it easier to perform tasks on time series data. By time series data we mean data for which each row contains 
a time parameter in addition to some numeric value. 

The time series normalization and augmentation consists of these three types of the functions:
<pre>
	normalilze_series_*
	augment_series_*	
	gapfilled_series_*
</pre>

<b>normalilze_series_*</b> is a set of functions that take irregular time interval series and return normalized time series. Caller can specify a time interval that should return
a result row. 

\verbatim
	Input:	
	5/11/2011 15:01:45 | 5.6
	5/11/2011 15:01:47 | 8.3
	5/11/2011 15:01:47 | 7.1
	5/11/2011 15:01:48 | 3.4
	
	Output:
	5/11/2011 15:01:45 | 5.6
	5/11/2011 15:01:46 | 5.6
	5/11/2011 15:01:47 | 7.1
	5/11/2011 15:01:48 | 3.4
\endverbatim

The rows with this interval will be generated and output will consist of evenly spaces (in time) rows with the value derived from the existing rows in the input table.
This value can either represent the last value that appeared in the input, that predated the output row; or would be the result of linear extrapolation between two neighboring rows.
Depending on the way the value is extrapolated these functions would be <b>normalilze_series_const</b> and <b>normalilze_series_avg</b>. 

<pre><em>normalilze_series_avg</em> (
    <em>row_time</em> TIMESTAMP,
    <em>row_value</em> FLOAT8,
    <em>desired_interval</em> INTERVAL
     <em>start_time</em> TIMESTAMP (Optional)
)</pre>

In addition two the necessary parameters caller can optionally include a timestamp as the last argument in the function call. This timestamp will be the starting point for the regularized timeseries
to be generated from. If no start time is specified the first timestamp that appears in the input will be taken as the start. Option to specify start time is useful if the output of the regularization/normalization is to be correlated with other time series outputs.

Interval of time currently supports any value from 1 second and up, in increments of 1 second. 

On more technical note: in many of the example function calls you will see <b>ORDER BY something, random()</b>. The technical reason for that is by default aggregate derived window function is based on range, hence it makes a single call to finalization function on each set of rows for which value of 'something' is the same. The shortest way to avoid this behavior is to make each row unique. Alternatively, another way is to explicitly declare window function to be row based: <b>ORDER BY something ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</b>. This will also execute correctly but is a bit longer to type.

All of the functions in this sub-section are followed by <b>UNSTRUCT</b> call. Until upcoming (Q4 2011) release of Greenplum there is no way to return a set of values from an aggregate or window function. 'Unstruct' takes a set of structures returned by the function call and turns it into a proper set of rows. Where the return per single row of input can contain 0 or many output rows.

@examp
\verbatim

=# SELECT * FROM test_values;

           ts            | symbol | id  |       bid       
-------------------------+--------+-----+-----------------
2011-07-20 15:56:40.7564 | IBM    | 966 | 1311202600.7564
2011-07-20 15:56:43.3564 | IBM    | 391 | 1311202603.3564 
2011-07-20 15:56:45.9564 | IBM    | 840 | 1311202605.9564 

=# SELECT (unstruct(G.k)).* as r, symbol FROM (SELECT normalilze_series_avg(ts, bid, '1 second'::interval) OVER(PARTITION BY symbol ORDER BY ts, random()) as k, symbol FROM test_values) as G;

        time_stamp        |      value      | symbol 
--------------------------+-----------------+--------
 2011-07-20 15:56:41.7564 | 1311202601.7564 | IBM
 2011-07-20 15:56:42.7564 | 1311202602.7564 | IBM
 2011-07-20 15:56:43.7564 | 1311202603.7564 | IBM
 2011-07-20 15:56:44.7564 | 1311202604.7564 | IBM
 2011-07-20 15:56:45.7564 | 1311202605.7564 | IBM
 
 =# SELECT (unstruct(G.k)).* as r, symbol FROM (SELECT normalilze_series_avg(ts, bid, '1 second'::interval, '2011-07-20 15:56:40'::TIMESTAMP) OVER(PARTITION BY symbol ORDER BY ts, random());
 
     time_stamp      |   value    | symbol 
---------------------+------------+--------
 2011-07-20 15:56:41 | 1311202601 | IBM
 2011-07-20 15:56:42 | 1311202602 | IBM
 2011-07-20 15:56:43 | 1311202603 | IBM
 2011-07-20 15:56:44 | 1311202604 | IBM
 2011-07-20 15:56:45 | 1311202605 | IBM
 
\endverbatim

<b>augment_series_</b> is a function that takes as an input a table of irregular time series data and augments it with regular rows, adding row with values identical to those that are produced by normalilze_series_. Hence after execution of this function one can be sure that the target table will contain all the values in the original table as well as values at the specific time intervals. It is called in the manner identical to normalilze_series_. That also means that it allows for option for start timestamp and two different way to extrapolate the missing values.

@examp
\verbatim

  =# SELECT (unstruct(G.k)).* as r, symbol FROM (SELECT augment_series_avg(ts, bid, '1 second'::interval) OVER(PARTITION BY symbol ORDER BY ts, random()) as k, symbol FROM test_values) as G;
 
        time_stamp        |      value      | symbol 
--------------------------+-----------------+--------
 2011-07-20 15:56:40.7564 | 1311202600.7564 | IBM
 2011-07-20 15:56:41.7564 | 1311202601.7564 | IBM
 2011-07-20 15:56:42.0564 | 1311202602.0564 | IBM
 2011-07-20 15:56:42.7564 | 1311202602.7564 | IBM
 2011-07-20 15:56:43.3564 | 1311202603.3564 | IBM
 2011-07-20 15:56:43.7564 | 1311202603.7564 | IBM
 2011-07-20 15:56:44.6564 | 1311202604.6564 | IBM
 2011-07-20 15:56:44.7564 | 1311202604.7564 | IBM
 2011-07-20 15:56:45.7564 | 1311202605.7564 | IBM
 2011-07-20 15:56:45.9564 | 1311202605.9564 | IBM
 2011-07-20 15:56:46.7564 | 1311202606.7564 | IBM
 2011-07-20 15:56:47.2564 | 1311202607.2564 | IBM
 2011-07-20 15:56:47.7564 | 1311202607.7564 | IBM
 2011-07-20 15:56:48.5564 | 1311202608.5564 | IBM
 2011-07-20 15:56:48.7564 | 1311202608.7564 | IBM
 2011-07-20 15:56:49.7564 | 1311202609.7564 | IBM
 2011-07-20 15:56:49.8564 | 1311202609.8564 | IBM
	
\endverbatim

<b>gapfilled_series_</b> is a function that takes as the input a table of irregular time series data; if in the original data there is a gap in the rows larger than some specified time interval a value or a set of values will be inserted to guarantee that there is no gap in the output. It is called in the manner identical to normalilze_series_. That also means that it allows for option for start timestamp and two different way to extrapolate the missing values.

  
@examp
\verbatim

=#SELECT * FROM test_values;

           ts            | symbol | id  |       bid       
-------------------------+--------+-----+-----------------
2011-07-20 15:56:40.7564 | IBM    | 966 | 1311202600.7564
2011-07-20 15:56:43.3564 | IBM    | 391 | 1311202603.3564 

=# SELECT (unstruct(G.k)).* as r, symbol FROM (SELECT gapfilled_series_avg(ts, bid, '.1 second'::interval) OVER(PARTITION BY symbol ORDER BY ts, random()) as k, symbol FROM test_values) as G;

        time_stamp        |      value      | symbol 
--------------------------+-----------------+--------
 2011-07-20 15:56:40.7564 | 1311202600.7564 | IBM
 2011-07-20 15:56:41.0564 | 1311202601.0564 | IBM
 2011-07-20 15:56:42.0564 | 1311202602.0564 | IBM
 2011-07-20 15:56:42.3564 | 1311202602.3564 | IBM
 
 =# SELECT (unstruct(G.k)).* as r, symbol FROM (SELECT gapfilled_series_avg(ts, bid, '1 second'::interval, '2011-07-20 15:56:42'::TIMESTAMP) OVER(PARTITION BY symbol ORDER BY ts, random()) as k, symbol FROM test_values) as G;
 
        time_stamp        |      value      | symbol 
--------------------------+-----------------+--------
 2011-07-20 15:56:42.0564 | 1311202602.0564 | IBM
 2011-07-20 15:56:42.3564 | 1311202602.3564 | IBM
 2011-07-20 15:56:43.3564 | 1311202603.3564 | IBM
 
\endverbatim

<b>Rolling Average</b>

There are three types of rolling average in this implementation of the library:

<pre>
	weighted_avg
	exponential_avg
	weighted_avg - with array 
</pre>

First two are computed as described in:
http://en.wikipedia.org/wiki/Moving_average

The last weighted_avg takes as an input array of weights and uses it to weigh samples in the specified window of rows. Notice that the array has to be of the same size as the window or larger,
but cannot be smaller. If values in the array do not add to one, they will be normalized to one before they are applied to the average. 

@examp
\verbatim

=# SELECT weighted_avg(bid) OVER(ORDER BY ts ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS w FROM test_values;
        w         
------------------
  1311202600.7564
 1311202601.62307
 1311202602.48973
  1311202603.3564
  1311202604.6564
  1311202605.9564
….

=# SELECT exponential_avg(bid, .1) OVER(ORDER BY ts ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS w FROM test_values;
        w        
-----------------
 1311202600.7564
 1311202600.8864
 1311202601.1334
 1311202601.4857
 1311202602.7857
 1311202604.0857
 1311202605.3857
 1311202606.6857
 
 ….
 
 =# SELECT weighted_avg(bid, ARRAY[12312,23222,34342,45565,345354]) OVER(ORDER BY ts ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS w FROM test_values;
        w         
------------------
  1311202600.7564
 1311202601.60597
 1311202602.46625
 1311202603.33071
 1311202604.63071
 1311202605.93071
 1311202607.23071
 1311202608.53071  
 ….
 
\endverbatim

<b>Time Intersept Joins</b>

These functions are used to join two timeseries tables where the goal is to obtain the latest preceding value from one table at the time of another. One can view this as a sort of fuzzy join. The first step is to take a union of the two tables. There are to schemas that are supported for that. In the first schema the result of the union is a table which consists of:

VALUE | ID_OF_VALUE | BOOLEAN

Where the boolean is the indicator weather a current row is the source of the value or it is a place to report timestamp and value. 
@examp
\verbatim

=# SELECT * FROM test_values ORDER BY ts;
            ts            | symbol | id  |       bid       
--------------------------+--------+-----+-----------------
 2011-07-20 15:56:40.7564 | IBM    | 966 | 1311202600.7564
 2011-07-20 15:56:42.0564 | IBM    | 807 | 1311202602.0564
 2011-07-20 15:56:43.3564 | IBM    | 391 | 1311202603.3564
 2011-07-20 15:56:44.6564 | IBM    | 400 | 1311202604.6564
 2011-07-20 15:56:45.9564 | IBM    | 840 | 1311202605.9564
 2011-07-20 15:56:47.2564 | IBM    | 576 | 1311202607.2564
 2011-07-20 15:56:48.5564 | IBM    | 579 | 1311202608.5564
 2011-07-20 15:56:49.8564 | IBM    | 895 | 1311202609.8564
 2011-07-20 15:56:51.1564 | IBM    | 731 | 1311202611.1564
 2011-07-20 15:56:52.4564 | IBM    | 972 | 1311202612.4564
 2011-07-20 15:56:53.7564 | IBM    | 451 | 1311202613.7564
 2011-07-20 15:56:55.0564 | IBM    |  12 | 1311202615.0564
 2011-07-20 15:56:56.3564 | IBM    | 448 | 1311202616.3564
 2011-07-20 15:56:57.6564 | IBM    |  68 | 1311202617.6564
 2011-07-20 15:56:58.9564 | IBM    | 206 | 1311202618.9564
 2011-07-20 15:57:00.2564 | IBM    | 129 | 1311202620.2564
 2011-07-20 15:57:01.5564 | IBM    | 723 | 1311202621.5564
 2011-07-20 15:57:02.8564 | IBM    | 299 | 1311202622.8564
 2011-07-20 15:57:04.1564 | IBM    | 446 | 1311202624.1564
 2011-07-20 15:57:05.4564 | IBM    | 933 | 1311202625.4564
 2011-07-20 15:57:06.7564 | IBM    | 615 | 1311202626.7564
 2011-07-20 15:57:08.0564 | IBM    | 649 | 1311202628.0564
 2011-07-20 15:57:09.3564 | IBM    | 572 | 1311202629.3564
 2011-07-20 15:57:10.6564 | IBM    | 299 | 1311202630.6564
 
 =# SELECT * FROM test_values1 WHERE symbol = 'IBM' ORDER BY ts;
            ts            | symbol | id  |       bid       
--------------------------+--------+-----+-----------------
 2011-07-20 15:56:41.1564 | IBM    |  51 | 1311202601.1564
 2011-07-20 15:56:41.1564 | IBM    | 163 | 1311202601.1564
 2011-07-20 15:56:46.2564 | IBM    | 952 | 1311202606.2564
 2011-07-20 15:56:46.2564 | IBM    | 160 | 1311202606.2564
 2011-07-20 15:56:51.3564 | IBM    | 942 | 1311202611.3564
 2011-07-20 15:56:51.3564 | IBM    | 767 | 1311202611.3564
 2011-07-20 15:56:56.4564 | IBM    | 365 | 1311202616.4564
 2011-07-20 15:56:56.4564 | IBM    | 569 | 1311202616.4564
 2011-07-20 15:57:06.6564 | IBM    | 296 | 1311202626.6564
 2011-07-20 15:57:06.6564 | IBM    | 417 | 1311202626.6564
 2011-07-20 15:57:11.7564 | IBM    | 112 | 1311202631.7564
 2011-07-20 15:57:11.7564 | IBM    | 644 | 1311202631.7564

=# SELECT * FROM (SELECT time_intercept(b2, id, b1) OVER(PARTITION by symbol order by ts range between '5 minute'::INTERVAL preceding and current row) as k, symbol, ts from (SELECT ts, NULL AS b1, id, symbol, bid AS b2 FROM test_values UNION ALL SELECT ts, bid AS b1, id, symbol, NULL AS b2 FROM test_values1) as g) as g WHERE g.k IS NOT NULL;
           k           | symbol |            ts            
-----------------------+--------+--------------------------
 (1311202600.7564,966) | IBM    | 2011-07-20 15:56:41.1564
 (1311202600.7564,966) | IBM    | 2011-07-20 15:56:41.1564
 (1311202605.9564,840) | IBM    | 2011-07-20 15:56:46.2564
 (1311202605.9564,840) | IBM    | 2011-07-20 15:56:46.2564
 (1311202611.1564,731) | IBM    | 2011-07-20 15:56:51.3564
 (1311202611.1564,731) | IBM    | 2011-07-20 15:56:51.3564
 (1311202616.3564,448) | IBM    | 2011-07-20 15:56:56.4564
 (1311202616.3564,448) | IBM    | 2011-07-20 15:56:56.4564
 (1311202625.4564,933) | IBM    | 2011-07-20 15:57:06.6564
 (1311202625.4564,933) | IBM    | 2011-07-20 15:57:06.6564
 (1311202630.6564,299) | IBM    | 2011-07-20 15:57:11.7564
 (1311202630.6564,299) | IBM    | 2011-07-20 15:57:11.7564

 
 =# SELECT * FROM (SELECT time_intercept(b2, id, b1) OVER(PARTITION by symbol order by ts range between '5 minute'::INTERVAL preceding and current row) as k, symbol, ts from (SELECT ts, NULL AS b1, id, symbol, bid AS b2 FROM test_values UNION ALL SELECT ts, bid AS b1, id, symbol, NULL AS b2 FROM test_values1) as g) as g WHERE g.k IS NOT NULL;
           k           | symbol |            ts            
-----------------------+--------+--------------------------
 (1311202600.7564,966) | IBM    | 2011-07-20 15:56:41.1564
 (1311202600.7564,966) | IBM    | 2011-07-20 15:56:41.1564
 (1311202605.9564,840) | IBM    | 2011-07-20 15:56:46.2564
 (1311202605.9564,840) | IBM    | 2011-07-20 15:56:46.2564
 (1311202611.1564,731) | IBM    | 2011-07-20 15:56:51.3564
 (1311202611.1564,731) | IBM    | 2011-07-20 15:56:51.3564
 (1311202616.3564,448) | IBM    | 2011-07-20 15:56:56.4564
 (1311202616.3564,448) | IBM    | 2011-07-20 15:56:56.4564
 (1311202625.4564,933) | IBM    | 2011-07-20 15:57:06.6564
 (1311202625.4564,933) | IBM    | 2011-07-20 15:57:06.6564
 (1311202630.6564,299) | IBM    | 2011-07-20 15:57:11.7564
 (1311202630.6564,299) | IBM    | 2011-07-20 15:57:11.7564
 
\endverbatim

In the case above we are using values from the <b>table test_values</b> to generate values for the table <b>test_values1</b>. In both calls shown we are interested only in values that are at most 5 minutes old, otherwise values are filled with NULLs. This interval can be set to any value of remain undefined, in which case all the values are acceptable. 

<b>Performance Evaluation</b>

The goal of this function is to evaluate response to a stimulus signal. Typical example would be a prediction engine for a trading firm that produces a prediction of the market behavior. One may want to see if stock market behaved in the manner predicted by the signal. This function provides a utility for doing that. One starts by creating a join of signal and response tables. There are two function that can be used for this. First scans through the table and for each signal row it accumulates an array of data that should contain response. Number of rows accumulated depends on time interval that is also provided as an argument to the function. 

Second function takes as the input OID (Object Identifier) of a function that is to be run on the accumulated array following each response function. This mode of execution is faster, but it requires writing a piece of C code that decomposes a binary encoded accumulated data. This function does the processing and returns an array of float values corresponding to the original signal, and a set of quality metrics of the response. It is meant to serve as the input to the regression function. There is a sample function that is provided that can be used as it is or serve as an example for creating a custom one. This function returns an array consisting of:

timestamp of the signal
initial signal
binary version if the signal (-1,1)
min value
max value
average value
return value (final value - start value)

@examp
\verbatim

=# SELECT * FROM test_start;
 trade |     trade_time      | trade_price | trade_quantity | signal 
-------+---------------------+-------------+----------------+--------
 t     | 2011-07-20 15:56:30 |           9 |            100 |       
 f     | 2011-07-20 15:56:31 |             |            100 |    1.5
 t     | 2011-07-20 15:56:33 |          11 |            200 |       
 t     | 2011-07-20 15:56:34 |          12 |            200 |       
 t     | 2011-07-20 15:56:36 |          14 |            200 |       
 t     | 2011-07-20 15:56:37 |          15 |            200 |       
 t     | 2011-07-20 15:56:38 |          16 |            200 |       
 t     | 2011-07-20 15:56:44 |          18 |            200 |       
 t     | 2011-07-20 15:56:32 |          10 |            200 |       
 t     | 2011-07-20 15:56:35 |          13 |            200 |       
 t     | 2011-07-20 15:56:39 |          17 |            200 |       
 f     | 2011-07-20 15:56:45 |             |            100 |   -1.5
 t     | 2011-07-20 15:56:46 |           3 |            100 |       
 t     | 2011-07-20 15:56:47 |           2 |            100 |       


SELECT * FROM (SELECT trade_time, performance_extract(g.k::INT4,'10 second'::interval, trade, trade_time, trade_price, trade_quantity, signal) OVER(ORDER BY trade_time DESC) as l FROM test_start, (SELECT find_function_oid('performance_window(bytea, INT8)') as k) as g) as k WHERE l IS NOT NULL ORDER BY trade_time;

     trade_time      |                   l                    
---------------------+----------------------------------------
 2011-07-20 15:56:32 | {364492591,1.5,1,1.875e-07,0,7,7,10}
 2011-07-20 15:56:46 | {364492605,-1.5,-1,-7.5e-07,-1,0,-1,3}
 
SELECT * FROM (SELECT trade_time, performance_extract('10 second'::interval, trade, trade_time, trade_price, trade_quantity, signal) OVER(ORDER BY trade_time DESC) as l FROM test_start, (SELECT find_function_oid('performance_window(bytea, INT8)') as k) as g) as k WHERE l IS NOT NULL ORDER BY trade_time;

     trade_time      |                                                                                                                                         l                                                                                                                                          
---------------------+----------------------------------------------------------------------------------------------------------------------------------------------
 2011-07-20 15:56:32 | ("{10,10,11,12,13,14,15,16,17}","{f,t,t,t,t,t,t,t,t}","{""2011-07-20 15:56:31"",""2011-07-20 15:56:32"",""2011-07-20 15:56:33"",""2011-07-20 15:56:34"",""2011-07-20 15:56:35"",""2011-07-20 15:56:36"",""2011-07-20 15:56:37"",""2011-07-20 15:56:38"",""2011-07-20 15:56:39""}")
 2011-07-20 15:56:46 | ("{3,3,2}","{f,t,t}","{""2011-07-20 15:56:45"",""2011-07-20 15:56:46"",""2011-07-20 15:56:47""}")

\endverbatim

OID of the function can be found by using <b>find_function_oid</b> function. In this example the input is a union of signal and response table where the first column indicates what a given row represents. TRUE for response rows (trading/tick data). FALSE for the signal. First example calls and internal evaluation function that is also include in the MADlib. OID of the function need to be checked every time function is redeclared since it is assigned at random. 

Second example returns structure containing arrays of values for each signals (in this case from the 10 sec following the signal). 

<b>Event Detection</b>

Event detection is a set of function that make a pass over the table and return an indication for each row weather it fits the event conditions or not. There are the functions:

event_detection_delta
event_detection_oid
event_detection_pearson

Delta function lets a user specify magnitude of change that should register as an event. Only in the cases where this condition is met returned value is 1, 0 otherwise. OID version of the function in addition to all the other parameters takes as the input OID of the function the should be ran on the internally for event detection on the specified window of values. 

Additionally there are two types of Pearson correlation functions. One takes as the input numeric column of the table and an array representing some pattern of behavior. This array may be smaller or larger than number of rows in the corresponding window. It will be resized and linearly extrapolated to an array of the same cardinality. Pearson correlation of the two arrays is returned. 

In the second version of the function is meant to find correlations between two time-series tables. One takes a union of the two tables, then those joined values are fed into the Pearson function together with a boolean which indicates wether the current row comes from the one or the other column. Returned result is also a pearson correlation and number of rows in specified time interval need not agree. 

@examp
\verbatim

=# SELECT madlib.event_detection_delta(bid, 4.8::FLOAT8) OVER(PARTITION BY symbol ORDER BY ts RANGE BETWEEN '5 sec'::INTERVAL PRECEDING AND CURRENT ROW) AS g FROM test_values ORDER BY symbol, ts;
 g 
---
 0
 0
 0
 0
 1
 0
 0
 0
 ...
 
 =# SELECT madlib.event_detection_pearson(bid, ARRAY[8,8,8,2]::FLOAT[]) OVER(PARTITION BY symbol ORDER BY ts RANGE BETWEEN '5 sec'::INTERVAL PRECEDING AND CURRENT ROW), symbol, ts FROM test_values ORDER BY symbol, ts;
 event_detection_pearson | symbol |            ts            
-------------------------+--------+--------------------------
                         | IBM    | 2011-07-20 15:56:40.7564
       -0.37796442679702 | IBM    | 2011-07-20 15:56:42.0564
      -0.250872545194987 | IBM    | 2011-07-20 15:56:43.3564
       -0.18786728344095 | IBM    | 2011-07-20 15:56:44.6564
      -0.187867287325544 | IBM    | 2011-07-20 15:56:45.9564
      -0.187867280738623 | IBM    | 2011-07-20 15:56:47.2564
      -0.187867271111586 | IBM    | 2011-07-20 15:56:48.5564
       -0.18786729509473 | IBM    | 2011-07-20 15:56:49.8564
 ...
 
 SELECT madlib.event_detection_pearson(bid, which) OVER(PARTITION BY symbol ORDER BY ts RANGE BETWEEN '5 sec'::INTERVAL PRECEDING AND CURRENT ROW), symbol, ts FROM (SELECT * FROM (SELECT *, TRUE AS which FROM test_values) AS k1 UNION ALL (SELECT *, FALSE AS which FROM test_values1)) as k ORDER BY symbol, ts;
 event_detection_pearson | symbol |            ts            
-------------------------+--------+--------------------------
                         | IBM    | 2011-07-20 15:56:40.7564
                         | IBM    | 2011-07-20 15:56:41.1564
                         | IBM    | 2011-07-20 15:56:41.1564
                         | IBM    | 2011-07-20 15:56:42.0564
                         | IBM    | 2011-07-20 15:56:43.3564
                         | IBM    | 2011-07-20 15:56:44.6564
                         | IBM    | 2011-07-20 15:56:45.9564
                         | IBM    | 2011-07-20 15:56:46.2564
                         | IBM    | 2011-07-20 15:56:46.2564
                         | IBM    | 2011-07-20 15:56:47.2564
                         | IBM    | 2011-07-20 15:56:48.5564
                         | IBM    | 2011-07-20 15:56:49.8564
                         | IBM    | 2011-07-20 15:56:51.1564
                         | IBM    | 2011-07-20 15:56:51.3564
                         | IBM    | 2011-07-20 15:56:51.3564
                         | IBM    | 2011-07-20 15:56:52.4564
                         | IBM    | 2011-07-20 15:56:53.7564
                         | IBM    | 2011-07-20 15:56:55.0564
                         | IBM    | 2011-07-20 15:56:56.3564
                         | IBM    | 2011-07-20 15:56:56.4564
                         | IBM    | 2011-07-20 15:56:56.4564
                         | IBM    | 2011-07-20 15:56:57.6564
                         | IBM    | 2011-07-20 15:56:58.9564
                         | IBM    | 2011-07-20 15:57:00.2564
      -0.129099459079598 | IBM    | 2011-07-20 15:57:01.5564
      -0.129099459079598 | IBM    | 2011-07-20 15:57:01.5564
      -0.129099459079598 | IBM    | 2011-07-20 15:57:01.5564
      -0.129099319387087 | IBM    | 2011-07-20 15:57:02.8564
      -0.129099373843486 | IBM    | 2011-07-20 15:57:04.1564
      -0.129099515903674 | IBM    | 2011-07-20 15:57:05.4564
                         | IBM    | 2011-07-20 15:57:06.6564
                         | IBM    | 2011-07-20 15:57:06.6564
\endverbatim

@sa File time_series.sql_in documenting the SQL functions.
*/

CREATE TYPE MADLIB_SCHEMA.series_type AS(
	time_stamp TIMESTAMP[],
	value FLOAT8[]
);

CREATE TYPE MADLIB_SCHEMA.series_return_type AS(
	time_stamp TIMESTAMP,
	value FLOAT8
);

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.unstruct(MADLIB_SCHEMA.series_type) RETURNS SETOF MADLIB_SCHEMA.series_return_type AS
'MODULE_PATHNAME', 'unstruct_series'
LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION MADLIB_SCHEMA.uniform_series_sfunc(FLOAT8[], TIMESTAMP, FLOAT8, INTERVAL) RETURNS FLOAT8[] 
AS 'MODULE_PATHNAME', 'uniform_series_sfunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.uniform_series_start_sfunc(FLOAT8[], TIMESTAMP, FLOAT8, INTERVAL, TIMESTAMP) RETURNS FLOAT8[] 
AS 'MODULE_PATHNAME', 'uniform_series_start_sfunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.uniform_series_prefunc(FLOAT8[], FLOAT8[]) RETURNS FLOAT8[] 
AS 'MODULE_PATHNAME', 'uniform_series_prefunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.uniform_series_finalfunc(FLOAT8[]) RETURNS MADLIB_SCHEMA.series_type 
AS 'MODULE_PATHNAME', 'uniform_series_finalfunc'
LANGUAGE C IMMUTABLE; 

CREATE FUNCTION MADLIB_SCHEMA.uniform_series_const_finalfunc(FLOAT8[]) RETURNS MADLIB_SCHEMA.series_type 
AS 'MODULE_PATHNAME', 'uniform_series_const_finalfunc'
LANGUAGE C IMMUTABLE; 

CREATE FUNCTION MADLIB_SCHEMA.uniform_series_include_original_finalfunc(FLOAT8[]) RETURNS MADLIB_SCHEMA.series_type 
AS 'MODULE_PATHNAME', 'uniform_series_include_original_finalfunc'
LANGUAGE C IMMUTABLE; 

CREATE FUNCTION MADLIB_SCHEMA.uniform_series_const_include_original_finalfunc(FLOAT8[]) RETURNS MADLIB_SCHEMA.series_type 
AS 'MODULE_PATHNAME', 'uniform_series_const_include_original_finalfunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.gapfilled_series_sfunc(FLOAT8[], TIMESTAMP, FLOAT8, INTERVAL) RETURNS FLOAT8[] 
AS 'MODULE_PATHNAME', 'gapfilled_series_sfunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.gapfilled_series_start_sfunc(FLOAT8[], TIMESTAMP, FLOAT8, INTERVAL, TIMESTAMP) RETURNS FLOAT8[] 
AS 'MODULE_PATHNAME', 'gapfilled_series_start_sfunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.gapfilled_series_prefunc(FLOAT8[], FLOAT8[]) RETURNS FLOAT8[] 
AS 'MODULE_PATHNAME', 'gapfilled_series_prefunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.gapfilled_series_finalfunc(FLOAT8[]) RETURNS MADLIB_SCHEMA.series_type 
AS 'MODULE_PATHNAME', 'gapfilled_series_finalfunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.gapfilled_series_const_finalfunc(FLOAT8[]) RETURNS MADLIB_SCHEMA.series_type 
AS 'MODULE_PATHNAME', 'gapfilled_series_finalfunc'
LANGUAGE C IMMUTABLE; 

/**
 * @brief This functions are meant to either turn unregular time series data into a regular one or augment time series with some derived values
 *
 * @param x Timestamp
 * @param y Float8
 * @param z Interval
 * @param s [Optional] Timestamp
 */

CREATE AGGREGATE MADLIB_SCHEMA.normalilze_series_avg(TIMESTAMP, FLOAT8, INTERVAL) (
       SFUNC = MADLIB_SCHEMA.uniform_series_sfunc,
       PREFUNC = MADLIB_SCHEMA.uniform_series_prefunc,
       FINALFUNC = MADLIB_SCHEMA.uniform_series_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{0,0}'
);

CREATE AGGREGATE MADLIB_SCHEMA.normalilze_series_avg(TIMESTAMP, FLOAT8, INTERVAL, TIMESTAMP) (
       SFUNC = MADLIB_SCHEMA.uniform_series_start_sfunc,
       PREFUNC = MADLIB_SCHEMA.uniform_series_prefunc,
       FINALFUNC = MADLIB_SCHEMA.uniform_series_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{0,0}'
);

CREATE AGGREGATE  MADLIB_SCHEMA.normalilze_series_const(TIMESTAMP, FLOAT8, INTERVAL) (
       SFUNC = MADLIB_SCHEMA.uniform_series_sfunc,
       PREFUNC = MADLIB_SCHEMA.uniform_series_prefunc,
       FINALFUNC = MADLIB_SCHEMA.uniform_series_const_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{0,0}'
);

CREATE AGGREGATE MADLIB_SCHEMA.normalilze_series_const(TIMESTAMP, FLOAT8, INTERVAL, TIMESTAMP) (
       SFUNC = MADLIB_SCHEMA.uniform_series_start_sfunc,
       PREFUNC = MADLIB_SCHEMA.uniform_series_prefunc,
       FINALFUNC = MADLIB_SCHEMA.uniform_series_const_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{0,0}'
);

CREATE AGGREGATE MADLIB_SCHEMA.augment_series_avg(TIMESTAMP, FLOAT8, INTERVAL) (
       SFUNC = MADLIB_SCHEMA.uniform_series_sfunc,
       PREFUNC = MADLIB_SCHEMA.uniform_series_prefunc,
       FINALFUNC = MADLIB_SCHEMA.uniform_series_include_original_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{0,0}'
);

CREATE AGGREGATE MADLIB_SCHEMA.augment_series_avg(TIMESTAMP, FLOAT8, INTERVAL, TIMESTAMP) (
       SFUNC = MADLIB_SCHEMA.uniform_series_start_sfunc,
       PREFUNC = MADLIB_SCHEMA.uniform_series_prefunc,
       FINALFUNC = MADLIB_SCHEMA.uniform_series_include_original_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{0,0}'
);

CREATE AGGREGATE MADLIB_SCHEMA.augment_series_const(TIMESTAMP, FLOAT8, INTERVAL) (
       SFUNC = MADLIB_SCHEMA.uniform_series_sfunc,
       PREFUNC = MADLIB_SCHEMA.uniform_series_prefunc,
       FINALFUNC = MADLIB_SCHEMA.uniform_series_const_include_original_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{0,0}'
);

CREATE AGGREGATE MADLIB_SCHEMA.augment_series_const(TIMESTAMP, FLOAT8, INTERVAL, TIMESTAMP) (
       SFUNC = MADLIB_SCHEMA.uniform_series_start_sfunc,
       PREFUNC = MADLIB_SCHEMA.uniform_series_prefunc,
       FINALFUNC = MADLIB_SCHEMA.uniform_series_const_include_original_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{0,0}'
);


CREATE AGGREGATE MADLIB_SCHEMA.gapfilled_series_avg(TIMESTAMP, FLOAT8, INTERVAL) (
       SFUNC = MADLIB_SCHEMA.gapfilled_series_sfunc,
       PREFUNC = MADLIB_SCHEMA.gapfilled_series_prefunc,
       FINALFUNC = MADLIB_SCHEMA.gapfilled_series_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{0,0}'
);

CREATE AGGREGATE MADLIB_SCHEMA.gapfilled_series_avg(TIMESTAMP, FLOAT8, INTERVAL, TIMESTAMP) (
       SFUNC = MADLIB_SCHEMA.gapfilled_series_start_sfunc,
       PREFUNC = MADLIB_SCHEMA.gapfilled_series_prefunc,
       FINALFUNC = MADLIB_SCHEMA.gapfilled_series_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{0,0}'
);

CREATE AGGREGATE MADLIB_SCHEMA.gapfilled_series_const(TIMESTAMP, FLOAT8, INTERVAL) (
       SFUNC = MADLIB_SCHEMA.gapfilled_series_sfunc,
       PREFUNC = MADLIB_SCHEMA.gapfilled_series_prefunc,
       FINALFUNC = MADLIB_SCHEMA.gapfilled_series_const_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{0,0}'
);

CREATE AGGREGATE MADLIB_SCHEMA.gapfilled_series_const(TIMESTAMP, FLOAT8, INTERVAL, TIMESTAMP) (
       SFUNC = MADLIB_SCHEMA.gapfilled_series_start_sfunc,
       PREFUNC = MADLIB_SCHEMA.gapfilled_series_prefunc,
       FINALFUNC = MADLIB_SCHEMA.gapfilled_series_const_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{0,0}'
);

/*
Weighted Average using finance definition 
*/
CREATE TYPE MADLIB_SCHEMA.avg_type_exp AS(
	val FLOAT8[],
	alpha FLOAT8
);

CREATE TYPE MADLIB_SCHEMA.avg_type_weight AS(
	val FLOAT8[],
	weight FLOAT8[]
);

CREATE FUNCTION MADLIB_SCHEMA.weighted_avg_finalfunc(FLOAT8[]) RETURNS FLOAT8 
AS 'MODULE_PATHNAME', 'weighted_avg_finalfunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.exponential_avg_sfunc(INOUT MADLIB_SCHEMA.avg_type_exp, value FLOAT8, alpha FLOAT8) RETURNS MADLIB_SCHEMA.avg_type_exp AS $$
BEGIN
	$1.alpha = $3;
	$1.val = array_append(COALESCE($1.val, '{}'), $2); 
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION MADLIB_SCHEMA.exponential_avg_prefunc(INOUT MADLIB_SCHEMA.avg_type_exp, MADLIB_SCHEMA.avg_type_exp) RETURNS MADLIB_SCHEMA.avg_type_exp AS $$
BEGIN
	$1.alpha = COALESCE($1.alpha,$2.alpha);
	$1.val = COALESCE($1.val, '{}')||COALESCE($2.val, '{}');
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION MADLIB_SCHEMA.exponential_avg_finalfunc(MADLIB_SCHEMA.avg_type_exp) RETURNS FLOAT8 
AS 'MODULE_PATHNAME', 'exponential_avg_finalfunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.weighted_avg_sfunc(INOUT MADLIB_SCHEMA.avg_type_weight, value FLOAT8, weight FLOAT8[]) RETURNS MADLIB_SCHEMA.avg_type_weight AS $$
BEGIN
	$1.weight = $3;
	$1.val = array_append(COALESCE($1.val, '{}'), $2); 
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION MADLIB_SCHEMA.weighted_avg_prefunc(INOUT MADLIB_SCHEMA.avg_type_weight, MADLIB_SCHEMA.avg_type_weight) RETURNS MADLIB_SCHEMA.avg_type_weight AS $$
BEGIN
	$1.weight = COALESCE($1.weight,$2.weight);
	$1.val = COALESCE($1.val, '{}')||COALESCE($2.val, '{}');
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION MADLIB_SCHEMA.weighted_avg_finalfunc(MADLIB_SCHEMA.avg_type_weight) RETURNS FLOAT8 
AS 'MODULE_PATHNAME', 'weighted_avg_finalfunc_full'
LANGUAGE C IMMUTABLE;

/**
 * @brief This function compute rolling weighted average on a series
 *
 * @param x Float8
 */

CREATE AGGREGATE MADLIB_SCHEMA.weighted_avg(FLOAT8) (
       SFUNC = array_append,
       PREFUNC = array_cat,
       FINALFUNC = MADLIB_SCHEMA.weighted_avg_finalfunc,
       STYPE = FLOAT8[],
       initcond = '{}'
);

/**
 * @brief This function compute rolling exponential average on a series
 *
 * @param x Float8
 * @param y Float8
 */

CREATE AGGREGATE MADLIB_SCHEMA.exponential_avg(FLOAT8, FLOAT8) (
       SFUNC = MADLIB_SCHEMA.exponential_avg_sfunc,
       PREFUNC = MADLIB_SCHEMA.exponential_avg_prefunc,
       FINALFUNC = MADLIB_SCHEMA.exponential_avg_finalfunc,
       STYPE = MADLIB_SCHEMA.avg_type_exp
);

/**
 * @brief This function compute rolling weighted by a vector average on a series
 *
 * @param x Float8
 * @param y Float8[]
 */
CREATE AGGREGATE MADLIB_SCHEMA.weighted_avg(FLOAT8, FLOAT8[]) (
       SFUNC = MADLIB_SCHEMA.weighted_avg_sfunc,
       PREFUNC = MADLIB_SCHEMA.weighted_avg_prefunc,
       FINALFUNC = MADLIB_SCHEMA.weighted_avg_finalfunc,
       STYPE = MADLIB_SCHEMA.avg_type_weight
);

/*

	time intercept query

*/

CREATE TYPE MADLIB_SCHEMA.at_time_type AS(
	value FLOAT8,
	id BIGINT,
	type BOOL
);

CREATE TYPE MADLIB_SCHEMA.at_time_return_type AS(
	value FLOAT8,
	id BIGINT
);

CREATE FUNCTION MADLIB_SCHEMA.at_time_sfunc(MADLIB_SCHEMA.at_time_type, FLOAT8, BIGINT, BOOL) RETURNS MADLIB_SCHEMA.at_time_type 
AS 'MODULE_PATHNAME', 'at_time_sfunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.at_time_sfunc(MADLIB_SCHEMA.at_time_type, FLOAT8, BIGINT, FLOAT8) RETURNS MADLIB_SCHEMA.at_time_type 
AS 'MODULE_PATHNAME', 'at_time_seprareate_rows_sfunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.at_time_prefunc(MADLIB_SCHEMA.at_time_type, MADLIB_SCHEMA.at_time_type) RETURNS MADLIB_SCHEMA.at_time_type 
AS 'MODULE_PATHNAME', 'at_time_prefunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.at_time_finalfunc(MADLIB_SCHEMA.at_time_type) RETURNS MADLIB_SCHEMA.at_time_return_type 
AS 'MODULE_PATHNAME', 'at_time_finalfunc'
LANGUAGE C IMMUTABLE;

CREATE AGGREGATE MADLIB_SCHEMA.time_intercept(FLOAT8, BIGINT, BOOL) (
       SFUNC = MADLIB_SCHEMA.at_time_sfunc,
       PREFUNC = MADLIB_SCHEMA.at_time_prefunc,
       FINALFUNC = MADLIB_SCHEMA.at_time_finalfunc,
       STYPE = MADLIB_SCHEMA.at_time_type
);

CREATE AGGREGATE MADLIB_SCHEMA.time_intercept(FLOAT8, BIGINT, FLOAT8) (
       SFUNC = MADLIB_SCHEMA.at_time_sfunc,
       PREFUNC = MADLIB_SCHEMA.at_time_prefunc,
       FINALFUNC = MADLIB_SCHEMA.at_time_finalfunc,
       STYPE = MADLIB_SCHEMA.at_time_type
);

/*
	Performance test 

OID of sfunc
INTERVAL of interest after a special row
BOOL special
TIMESTAMP of the current row
PRICE of the current transaciton
*/

CREATE TYPE MADLIB_SCHEMA.performance_type AS(
	value_array FLOAT8[],
	trade_signal BOOL[],
	timestamp_array TIMESTAMP[]
);

/*
	Sample function to used for the evaluation
*/

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.performance_window(bytea, INT8) RETURNS FLOAT8[] 
AS 'MODULE_PATHNAME', 'performance_window' LANGUAGE C IMMUTABLE ;

/*
	Evaluaton window function.
*/


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.performance_array_window_sfunc(INT8, INTERVAL, BOOL, TIMESTAMP, FLOAT8, INT8, FLOAT8) RETURNS INT8 
AS 'MODULE_PATHNAME', 'performance_array_window_sfunc' LANGUAGE C IMMUTABLE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.performance_array_window_prefunc(INT8, INT8) RETURNS INT8 
AS 'MODULE_PATHNAME', 'performance_array_window_prefunc' LANGUAGE C IMMUTABLE ;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.performance_array_window_finalfunc(INT8) RETURNS MADLIB_SCHEMA.performance_type 
AS 'MODULE_PATHNAME', 'performance_array_window_finalfunc' LANGUAGE C IMMUTABLE ;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.performance_array_window_fast_sfunc(INT8, INT4, INTERVAL, BOOL, TIMESTAMP, FLOAT8, INT8, FLOAT8) RETURNS INT8 
AS 'MODULE_PATHNAME', 'performance_array_window_fast_sfunc' LANGUAGE C IMMUTABLE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.performance_array_window_fast_finalfunc(INT8) RETURNS FLOAT8[] 
AS 'MODULE_PATHNAME', 'performance_array_window_fast_finalfunc' LANGUAGE C IMMUTABLE ;

CREATE AGGREGATE MADLIB_SCHEMA.performance_extract(INTERVAL, BOOL, TIMESTAMP, FLOAT8, INT8, FLOAT8) (
       SFUNC = MADLIB_SCHEMA.performance_array_window_sfunc,
       PREFUNC = MADLIB_SCHEMA.performance_array_window_prefunc,
       FINALFUNC = MADLIB_SCHEMA.performance_array_window_finalfunc,
       STYPE = INT8
);

CREATE AGGREGATE MADLIB_SCHEMA.performance_extract(INT4, INTERVAL, BOOL, TIMESTAMP, FLOAT8, INT8, FLOAT8) (
       SFUNC = MADLIB_SCHEMA.performance_array_window_fast_sfunc,
       PREFUNC = MADLIB_SCHEMA.performance_array_window_prefunc,
       FINALFUNC = MADLIB_SCHEMA.performance_array_window_fast_finalfunc,
       STYPE = INT8
);

/*
	Determine OID of a function 

*/

CREATE FUNCTION MADLIB_SCHEMA.find_function_oid(TEXT) RETURNS INT4 AS $$
DECLARE
	oid_val INT4;
BEGIN
	EXECUTE 'SELECT '''||$1||'''::regprocedure::int4;' INTO oid_val;
	RETURN oid_val;
END
$$ LANGUAGE plpgsql;

/*
	Event Detection
*/

CREATE TYPE MADLIB_SCHEMA.event_detection_type AS(
	val FLOAT8[],
	OID INT4,
	input FLOAT8[]
);

CREATE TYPE MADLIB_SCHEMA.event_detection_pearson_type AS(
	val FLOAT8[],
	ref FLOAT8[]
);

CREATE FUNCTION MADLIB_SCHEMA.event_detection_sfunc(INOUT MADLIB_SCHEMA.event_detection_type, value FLOAT8, OID INT4, input FLOAT8[]) RETURNS MADLIB_SCHEMA.event_detection_type AS $$
BEGIN
	IF($1.OID IS NULL) THEN
		$1.OID = $3;
		$1.input = input;
	END IF;
	$1.val = array_append(COALESCE($1.val, '{}'), $2); 
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION MADLIB_SCHEMA.event_detection_sfunc(INOUT FLOAT8[], value FLOAT8, delta FLOAT) RETURNS FLOAT8[] AS $$
BEGIN
	 IF(COALESCE($1[1],value) >= value) THEN
	 	$1[1] = value;
	 END IF;
	 IF(COALESCE($1[2],value) <= value) THEN
	 	$1[2] = value;
	 END IF;
	 $1[3] = delta;
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION MADLIB_SCHEMA.event_detection_prefunc(INOUT MADLIB_SCHEMA.event_detection_type, MADLIB_SCHEMA.event_detection_type) RETURNS MADLIB_SCHEMA.event_detection_type AS $$
BEGIN
	$1.OID = COALESCE($1.OID,$2.OID);
	$1.input = COALESCE($1.input,$2.input);
	$1.val = COALESCE($1.val, '{}')||COALESCE($2.val, '{}');
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION MADLIB_SCHEMA.event_detection_prefunc(INOUT FLOAT8[], FLOAT8[]) RETURNS FLOAT8[] AS $$
BEGIN
	IF(COALESCE($1[1],$2[1]) >= COALESCE($2[1],$1[1])) THEN
		$1[1] = $2[1];
	END IF;
	IF(COALESCE($1[2],$2[2]) <= COALESCE($2[2],$1[2])) THEN
		$1[2] = $2[2];
	END IF;
	$1[3] = COALESCE($1[3], $2[3]);
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION MADLIB_SCHEMA.event_detection_finalfunc(FLOAT8[]) RETURNS FLOAT8 AS $$
BEGIN
	IF(($1[2]-$1[1]) >= $1[3]) THEN
		RETURN 1.0;
	ELSE
		RETURN 0.0;
	END IF;
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION MADLIB_SCHEMA.event_detection_passOID_finalfunc(MADLIB_SCHEMA.event_detection_type) RETURNS FLOAT8 
AS 'MODULE_PATHNAME', 'event_detection_passOID_finalfunc'
LANGUAGE C IMMUTABLE;

CREATE FUNCTION MADLIB_SCHEMA.event_detection_pearson_sfunc(INOUT MADLIB_SCHEMA.event_detection_pearson_type, value FLOAT8, ref FLOAT8[]) RETURNS MADLIB_SCHEMA.event_detection_pearson_type AS $$
BEGIN
	if($1.ref IS NULL) THEN
		$1.ref = $3;
	END IF;
	$1.val = array_append(COALESCE($1.val, '{}'),$2); 
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION MADLIB_SCHEMA.event_detection_pearson_prefunc(INOUT MADLIB_SCHEMA.event_detection_pearson_type, MADLIB_SCHEMA.event_detection_pearson_type) RETURNS MADLIB_SCHEMA.event_detection_pearson_type AS $$
BEGIN
	$1.ref = COALESCE($1.ref, '{}')||COALESCE($2.ref, '{}');
	$1.val = COALESCE($1.val, '{}')||COALESCE($2.val, '{}');
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION MADLIB_SCHEMA.event_detection_comp_sfunc(INOUT MADLIB_SCHEMA.event_detection_pearson_type, value FLOAT8, BOOL) RETURNS MADLIB_SCHEMA.event_detection_pearson_type AS $$
BEGIN
	IF($3) THEN
		$1.val = array_append(COALESCE($1.val, '{}'),$2);
	ELSE
		$1.ref = array_append(COALESCE($1.ref, '{}'),$2);
	END IF; 
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION MADLIB_SCHEMA.event_detection_pearson_finalfunc(MADLIB_SCHEMA.event_detection_pearson_type) RETURNS FLOAT8 
AS 'MODULE_PATHNAME', 'event_detection_pearson_finalfunc'
LANGUAGE C IMMUTABLE;

CREATE AGGREGATE MADLIB_SCHEMA.event_detection_delta(FLOAT8, FLOAT8) (
       SFUNC = MADLIB_SCHEMA.event_detection_sfunc,
       PREFUNC = MADLIB_SCHEMA.event_detection_prefunc,
       FINALFUNC = MADLIB_SCHEMA.event_detection_finalfunc,
       STYPE = FLOAT8[]
);

CREATE AGGREGATE MADLIB_SCHEMA.event_detection_oid(FLOAT8, INT4, FLOAT8[]) (
       SFUNC = MADLIB_SCHEMA.event_detection_sfunc,
       PREFUNC = MADLIB_SCHEMA.event_detection_prefunc,
       FINALFUNC = MADLIB_SCHEMA.event_detection_passOID_finalfunc,
       STYPE = MADLIB_SCHEMA.event_detection_type
);

CREATE AGGREGATE MADLIB_SCHEMA.event_detection_pearson(FLOAT8, FLOAT8[]) (
       SFUNC = MADLIB_SCHEMA.event_detection_pearson_sfunc,
       PREFUNC = MADLIB_SCHEMA.event_detection_pearson_prefunc,
       FINALFUNC = MADLIB_SCHEMA.event_detection_pearson_finalfunc,
       STYPE = MADLIB_SCHEMA.event_detection_pearson_type
);

CREATE AGGREGATE MADLIB_SCHEMA.event_detection_pearson(FLOAT8, BOOL) (
       SFUNC = MADLIB_SCHEMA.event_detection_comp_sfunc,
       PREFUNC = MADLIB_SCHEMA.event_detection_pearson_prefunc,
       FINALFUNC = MADLIB_SCHEMA.event_detection_pearson_finalfunc,
       STYPE = MADLIB_SCHEMA.event_detection_pearson_type
);

